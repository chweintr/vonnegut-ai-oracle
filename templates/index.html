<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vonnebot</title>
  <!-- Simli Widget SDK (for Talk mode) -->
  <script src="https://app.simli.com/simli-widget/index.js" defer></script>
  <!-- LiveKit Web SDK (for future full agent integration) -->
  <script src="https://unpkg.com/livekit-client@2.0.0/dist/livekit-client.umd.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Special+Elite&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Caveat:wght@400;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --cream: #f4f1e8;
      --paper: #ebe6d9;
      --ink: #2a2520;
      --pencil: #5c5549;
      --rust: #c4653a;
      --gold: #d4a853;
      --blue-ink: #3d5a73;
    }

    body {
      background: var(--cream);
      min-height: 100vh;
      font-family: 'Libre Baskerville', Georgia, serif;
      color: var(--ink);
      overflow-x: hidden;
    }

    /* Noise texture overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.03;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
      z-index: 1000;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 380px;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
    }

    /* ========== HEADER ========== */
    .header {
      grid-column: 1 / -1;
      padding: 1.5rem 2rem;
      display: flex;
      align-items: baseline;
      gap: 1rem;
      border-bottom: 1px solid var(--pencil);
      position: relative;
    }

    .header::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 2rem;
      right: 2rem;
      height: 1px;
      background: var(--pencil);
      opacity: 0.3;
    }

    .logo {
      font-family: 'Special Elite', monospace;
      font-size: 1.8rem;
      letter-spacing: 0.05em;
      color: var(--ink);
      transform: rotate(-1deg);
    }

    .tagline {
      font-family: 'Caveat', cursive;
      font-size: 1.2rem;
      color: var(--pencil);
      margin-left: auto;
      transform: rotate(1deg);
    }

    /* Asterisk doodle */
    .asterisk-doodle {
      font-family: 'Caveat', cursive;
      font-size: 2rem;
      color: var(--rust);
      opacity: 0.6;
      margin-left: 1rem;
    }

    /* ========== READING PANE ========== */
    .reading-pane {
      padding: 2rem;
      border-right: 1px solid var(--pencil);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      position: relative;
    }

    .book-select {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .book-select-label {
      font-family: 'Special Elite', monospace;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--pencil);
    }

    .book-select select {
      flex: 1;
      padding: 0.6rem 1rem;
      font-family: 'Libre Baskerville', serif;
      font-size: 0.95rem;
      background: var(--paper);
      border: 1px solid var(--pencil);
      border-radius: 2px;
      color: var(--ink);
      cursor: pointer;
      max-width: 400px;
    }

    .page-container {
      flex: 1;
      background: white;
      border: 1px solid var(--pencil);
      border-radius: 2px;
      padding: 3rem;
      position: relative;
      box-shadow:
        2px 2px 0 var(--paper),
        4px 4px 0 #e0dbd0,
        6px 6px 12px rgba(0,0,0,0.08);
      overflow-y: auto;
      max-height: calc(100vh - 200px);
    }

    /* Page edge effect */
    .page-container::before {
      content: '';
      position: absolute;
      right: 0;
      top: 10%;
      bottom: 10%;
      width: 3px;
      background: linear-gradient(
        to bottom,
        transparent,
        var(--pencil) 20%,
        var(--pencil) 80%,
        transparent
      );
      opacity: 0.1;
    }

    .chapter-title {
      font-family: 'Special Elite', monospace;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--pencil);
      margin-bottom: 2rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px dashed var(--pencil);
    }

    .book-text {
      font-size: 1.05rem;
      line-height: 1.9;
      color: var(--ink);
      max-width: 60ch;
    }

    .book-text p {
      margin-bottom: 1.5em;
      text-indent: 1.5em;
    }

    .book-text p:first-of-type {
      text-indent: 0;
    }

    .book-text p:first-of-type::first-letter {
      font-size: 3.5em;
      float: left;
      line-height: 0.8;
      margin-right: 0.1em;
      margin-top: 0.1em;
      color: var(--rust);
    }

    /* Current reading indicator */
    .current-passage {
      background: linear-gradient(
        90deg,
        rgba(212, 168, 83, 0.15) 0%,
        rgba(212, 168, 83, 0.08) 100%
      );
      margin-left: -1rem;
      padding-left: 1rem;
      border-left: 2px solid var(--gold);
    }

    /* Empty state */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--pencil);
      text-align: center;
      gap: 1rem;
      padding: 3rem;
    }

    .empty-state-icon {
      font-size: 3rem;
      opacity: 0.4;
    }

    .empty-state-text {
      font-family: 'Caveat', cursive;
      font-size: 1.3rem;
    }

    /* ========== COMPANION PANE ========== */
    .companion-pane {
      padding: 2rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      background: var(--paper);
    }

    /* Avatar area */
    .avatar-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      flex-shrink: 0;
      padding-bottom: 0.5rem;
    }

    /*
     * IDLE VIDEO MODE (Text mode)
     * Shows blinking Vonnegut video in a circle
     */
    .avatar-wrapper {
      width: 200px;
      height: 200px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      isolation: isolate;
    }

    .avatar-wrapper.hidden {
      display: none;
    }

    .avatar-container {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--pencil);
      background: var(--cream);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .avatar-container video {
      width: 100%;
      height: 100%;
      border: none;
      object-fit: cover;
    }

    /*
     * SIMLI WIDGET MODE (Talk mode)
     * Constrain widget to match the idle video circle size (200x200)
     */
    .simli-wrapper {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .simli-wrapper.active {
      display: flex;
    }

    /*
     * Container that clips the widget to a circle
     * The widget renders larger internally, we just show a circular window
     */
    #simliWidgetContainer {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--pencil);
      background: #000;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /*
     * Position widget so face is centered in the circle
     * Widget renders at ~400x400, we offset to show just the face area
     */
    #simliWidgetContainer simli-widget {
      display: block;
      position: absolute;
      /* These values may need adjustment based on widget's actual rendering */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    /*
     * Start button - positioned below the circular container
     * We'll create our own button that triggers Simli's internal one
     */
    .simli-start-btn {
      font-family: 'Special Elite', monospace;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      padding: 0.5rem 1.2rem;
      background: var(--rust);
      color: var(--cream);
      border: none;
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 0.5rem;
    }

    .simli-start-btn:hover {
      background: var(--ink);
      transform: translateY(-1px);
    }

    .simli-start-btn.hidden {
      display: none;
    }

    /* Breathing animation behind avatar - only when no video playing */
    .avatar-container::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(92, 85, 73, 0.1) 0%, transparent 70%);
      animation: breathe 4s ease-in-out infinite;
      z-index: -1;
    }

    @keyframes breathe {
      0%, 100% { transform: scale(0.95); opacity: 0.3; }
      50% { transform: scale(1.05); opacity: 0.6; }
    }

    .avatar-label {
      font-family: 'Caveat', cursive;
      font-size: 1.1rem;
      color: var(--pencil);
      text-align: center;
    }

    .voice-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-family: 'Special Elite', monospace;
      font-size: 0.75rem;
      color: var(--pencil);
      cursor: pointer;
      padding: 0.4rem 0.8rem;
      border: 1px dashed var(--pencil);
      border-radius: 2px;
      background: transparent;
      transition: all 0.2s;
    }

    .voice-toggle:hover {
      background: var(--cream);
      border-style: solid;
    }

    .voice-toggle.active {
      background: var(--rust);
      color: var(--cream);
      border-color: var(--rust);
      border-style: solid;
    }

    /* Mode toggle buttons */
    .mode-toggle {
      display: flex;
      gap: 0.25rem;
      background: var(--cream);
      padding: 0.25rem;
      border-radius: 4px;
      border: 1px solid var(--pencil);
    }

    .mode-btn {
      font-family: 'Special Elite', monospace;
      font-size: 0.7rem;
      padding: 0.4rem 0.6rem;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 2px;
      color: var(--pencil);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .mode-btn:hover {
      background: white;
      border-color: var(--pencil);
    }

    .mode-btn.active {
      background: var(--ink);
      color: var(--cream);
      border-color: var(--ink);
    }

    .mode-btn span {
      font-size: 0.9rem;
    }

    /* Speaking indicator */
    .speaking-indicator {
      display: none;
      align-items: center;
      gap: 0.4rem;
      font-family: 'Special Elite', monospace;
      font-size: 0.75rem;
      color: var(--rust);
      padding: 0.3rem 0;
    }

    .speaking-indicator.visible {
      display: flex;
    }

    .speaking-indicator .wave {
      display: flex;
      gap: 2px;
      align-items: center;
    }

    .speaking-indicator .wave span {
      display: inline-block;
      width: 3px;
      height: 10px;
      background: var(--rust);
      animation: wave 0.5s ease-in-out infinite;
    }

    .speaking-indicator .wave span:nth-child(2) { animation-delay: 0.1s; }
    .speaking-indicator .wave span:nth-child(3) { animation-delay: 0.2s; }
    .speaking-indicator .wave span:nth-child(4) { animation-delay: 0.3s; }

    @keyframes wave {
      0%, 100% { height: 4px; }
      50% { height: 12px; }
    }

    /* Chat area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-height: 0;
    }

    .chat-header {
      font-family: 'Special Elite', monospace;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--pencil);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding-right: 0.5rem;
      max-height: 45vh;
    }

    .chat-messages::-webkit-scrollbar {
      width: 4px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: var(--pencil);
      border-radius: 2px;
    }

    /* Message styling */
    .message {
      max-width: 95%;
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .message.bot {
      align-self: flex-start;
      position: relative;
      padding-left: 1rem;
    }

    .message.bot::before {
      content: '"';
      position: absolute;
      left: 0;
      top: -0.2em;
      font-family: 'Libre Baskerville', serif;
      font-size: 1.5em;
      color: var(--rust);
      opacity: 0.6;
    }

    .message.bot .text {
      font-style: italic;
      color: var(--ink);
    }

    .message.bot .signature {
      font-family: 'Caveat', cursive;
      font-size: 0.9rem;
      color: var(--pencil);
      margin-top: 0.5rem;
      text-align: right;
    }

    /* Animated K.V.*bot signature */
    .message.bot .signature .bot-suffix {
      display: inline-block;
    }

    .message.bot .signature .asterisk {
      display: inline-block;
      animation: asterisk-blink 0.8s ease-in-out;
    }

    .message.bot .signature .bot-letter {
      display: inline-block;
      opacity: 0;
      animation: type-letter 0.1s ease-out forwards;
    }

    @keyframes asterisk-blink {
      0%, 40% { opacity: 1; }
      20% { opacity: 0.3; }
      60%, 100% { opacity: 1; }
    }

    @keyframes type-letter {
      to { opacity: 1; }
    }

    /* About section */
    .about-section {
      margin-top: 1rem;
      padding-top: 0.5rem;
      border-top: 1px dashed var(--pencil);
      font-size: 0.8rem;
      color: var(--pencil);
    }

    .about-section summary {
      cursor: pointer;
      font-family: 'Special Elite', monospace;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--pencil);
    }

    .about-section summary:hover {
      color: var(--rust);
    }

    .about-section p {
      margin-top: 0.75rem;
      line-height: 1.6;
      font-size: 0.8rem;
    }

    /* Doodle message */
    .message.bot.doodle .doodle-container {
      text-align: center;
      padding: 1rem 0;
    }

    .message.bot.doodle .doodle-container img {
      max-width: 150px;
      max-height: 150px;
      opacity: 0.85;
    }

    .message.bot.doodle .doodle-caption {
      font-family: 'Caveat', cursive;
      font-size: 0.95rem;
      color: var(--pencil);
      margin-top: 0.5rem;
      font-style: italic;
    }

    .message.user {
      align-self: flex-end;
      background: white;
      padding: 0.8rem 1rem;
      border-radius: 2px;
      border: 1px solid var(--pencil);
      box-shadow: 2px 2px 0 var(--cream);
    }

    /* Typing indicator */
    .typing-indicator {
      display: none;
      align-items: center;
      gap: 0.3rem;
      padding: 0.5rem 0;
      font-family: 'Special Elite', monospace;
      font-size: 0.8rem;
      color: var(--pencil);
    }

    .typing-indicator.visible {
      display: flex;
    }

    .typing-indicator span {
      display: inline-block;
      animation: typewriter-blink 1s steps(2) infinite;
    }

    .typing-indicator span:nth-child(2) { animation-delay: 0.15s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.3s; }

    @keyframes typewriter-blink {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* Input area */
    .input-area {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .chat-input {
      width: 100%;
      padding: 0.8rem 1rem;
      font-family: 'Libre Baskerville', serif;
      font-size: 0.95rem;
      background: white;
      border: 1px solid var(--pencil);
      border-radius: 2px;
      color: var(--ink);
      resize: none;
      min-height: 60px;
    }

    .chat-input::placeholder {
      color: var(--pencil);
      font-style: italic;
    }

    .chat-input:focus {
      outline: none;
      border-color: var(--rust);
      box-shadow: 0 0 0 1px var(--rust);
    }

    .send-btn {
      align-self: flex-end;
      font-family: 'Special Elite', monospace;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      padding: 0.5rem 1.2rem;
      background: var(--ink);
      color: var(--cream);
      border: none;
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .send-btn:hover {
      background: var(--rust);
      transform: translateY(-1px);
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Footer */
    .footer-note {
      font-family: 'Caveat', cursive;
      font-size: 1rem;
      color: var(--pencil);
      text-align: center;
      opacity: 0.6;
      padding-top: 0.5rem;
      border-top: 1px dashed var(--pencil);
    }

    /* Registration marks */
    .reg-mark {
      position: fixed;
      width: 16px;
      height: 16px;
      opacity: 0.2;
      z-index: 10;
    }

    .reg-mark::before,
    .reg-mark::after {
      content: '';
      position: absolute;
      background: var(--pencil);
    }

    .reg-mark::before {
      width: 100%;
      height: 1px;
      top: 50%;
    }

    .reg-mark::after {
      width: 1px;
      height: 100%;
      left: 50%;
    }

    .reg-mark.top-left { top: 1rem; left: 1rem; }
    .reg-mark.bottom-right { bottom: 1rem; right: 1rem; }

    /* Welcome message */
    .welcome-message {
      text-align: center;
      color: var(--pencil);
      font-style: italic;
      padding: 2rem 1rem;
    }

    /* ========== RESPONSIVE ========== */
    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr 1fr;
      }

      .reading-pane {
        border-right: none;
        border-bottom: 1px solid var(--pencil);
      }

      .page-container {
        max-height: 50vh;
      }

      .chat-messages {
        max-height: 30vh;
      }
    }
  </style>
</head>
<body>
  <div class="reg-mark top-left"></div>
  <div class="reg-mark bottom-right"></div>

  <div class="container">
    <header class="header">
      <h1 class="logo">VONNEBOT</h1>
      <span class="asterisk-doodle">*</span>
      <span class="tagline">And so it reads...</span>
    </header>

    <!-- Reading Pane -->
    <main class="reading-pane">
      <div class="book-select">
        <label class="book-select-label" for="book">Text:</label>
        <select id="book">
          <option value="">-- Select a text --</option>
          {% for text in texts %}
          <option value="{{ text }}">{{ text }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="page-container">
        <div id="bookContent">
          <div class="empty-state">
            <div class="empty-state-icon">*</div>
            <div class="empty-state-text">Select a text above to begin reading with Kurt.</div>
          </div>
        </div>
      </div>
    </main>

    <!-- Companion Pane -->
    <aside class="companion-pane">
      <div class="avatar-area">
        <!-- TEXT MODE: Idle video in circle -->
        <div class="avatar-wrapper" id="idleWrapper">
          <div class="avatar-container" id="avatarContainer">
            <video
              id="idleVideo"
              src="/static/vonnegut_blinking.mp4"
              autoplay
              loop
              muted
              playsinline
            ></video>
          </div>
        </div>

        <!-- TALK MODE: Simli widget constrained to circle with proxy Start button -->
        <div class="simli-wrapper" id="simliWrapper">
          <div id="simliWidgetContainer"></div>
          <button class="simli-start-btn" id="simliStartBtn">Start Conversation</button>
        </div>

        <span class="avatar-label" id="avatarLabel">Kurt is listening...</span>

        <!-- Mode Toggle -->
        <div class="mode-toggle" id="modeToggle">
          <button class="mode-btn active" data-mode="text" title="Type to chat (fast)">
            <span>&#9998;</span> Text
          </button>
          <button class="mode-btn" data-mode="talk" title="Voice conversation with Kurt">
            <span>&#127908;</span> Talk
          </button>
        </div>
      </div>

      <div class="chat-area">
        <div class="chat-header">
          <span>&#9998;</span> Conversation
        </div>

        <div class="chat-messages" id="chatMessages">
          <div class="welcome-message">
            Ask me anything about what you're reading. Or just say hello.
          </div>
        </div>

        <div class="typing-indicator" id="typingIndicator">
          <span>.</span><span>.</span><span>.</span>
        </div>

        <div class="speaking-indicator" id="speakingIndicator">
          <div class="wave">
            <span></span><span></span><span></span><span></span>
          </div>
          Kurt is speaking...
        </div>

        <div class="input-area">
          <textarea
            class="chat-input"
            id="chatInput"
            placeholder="What do you make of this passage?"
          ></textarea>
          <button class="send-btn" id="sendBtn">Send</button>
        </div>
      </div>

      <div class="footer-note">So it goes.</div>

      <details class="about-section">
        <summary>About Vonnebot</summary>
        <p>
          Vonnebot is an AI tool trained on Kurt Vonnegut's writings to offer readers additional context and insights.
          It's a way to engage with his work interactively—not a literal channeling of Vonnegut himself.
          Born in 1922, he had his own views on technology; while we think he might have found this intriguing,
          we acknowledge this is just an approximation. Our aim is to bring his literature to life for
          contemporary readers in a dynamic way. <strong>This project is not affiliated with or endorsed by the Vonnegut estate.</strong>
        </p>
      </details>
    </aside>
  </div>

  <script>
    // ========== DOM REFS ==========
    const bookSelect = document.getElementById('book');
    const bookContent = document.getElementById('bookContent');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const typingIndicator = document.getElementById('typingIndicator');
    const speakingIndicator = document.getElementById('speakingIndicator');
    const modeToggle = document.getElementById('modeToggle');
    const avatarLabel = document.getElementById('avatarLabel');
    const idleVideo = document.getElementById('idleVideo');
    const idleWrapper = document.getElementById('idleWrapper');
    const simliWrapper = document.getElementById('simliWrapper');
    const simliWidgetContainer = document.getElementById('simliWidgetContainer');
    const simliStartBtn = document.getElementById('simliStartBtn');

    // ========== STATE ==========
    let chatHistory = [];
    let currentPassageIndex = 0;
    let currentParagraphs = [];
    let currentMode = 'text'; // 'text' or 'talk'
    let simliWidget = null;
    let simliInitialized = false;
    let audioQueue = [];
    let isPlayingAudio = false;

    // ========== HELPERS ==========

    function addMessage(content, type = 'bot', doodle = null) {
      // Remove welcome message if present
      const welcome = chatMessages.querySelector('.welcome-message');
      if (welcome) welcome.remove();

      const msg = document.createElement('div');
      msg.className = `message ${type}`;

      if (type === 'bot') {
        const rotation = (Math.random() - 0.5) * 0.8;
        msg.style.transform = `rotate(${rotation}deg)`;

        if (doodle) {
          // Doodle response
          msg.classList.add('doodle');
          msg.innerHTML = `
            <div class="doodle-container">
              <img src="/static/doodles/${doodle.image}" alt="${doodle.alt || 'doodle'}">
              ${doodle.caption ? `<div class="doodle-caption">${doodle.caption}</div>` : ''}
            </div>
            <div class="signature">— K.V.<span class="bot-suffix"><span class="asterisk">*</span><span class="bot-letter" style="animation-delay: 0.8s">b</span><span class="bot-letter" style="animation-delay: 0.9s">o</span><span class="bot-letter" style="animation-delay: 1.0s">t</span></span></div>
          `;
        } else {
          // Text response with animated signature
          msg.innerHTML = `
            <div class="text">${content}</div>
            <div class="signature">— K.V.<span class="bot-suffix"><span class="asterisk">*</span><span class="bot-letter" style="animation-delay: 0.8s">b</span><span class="bot-letter" style="animation-delay: 0.9s">o</span><span class="bot-letter" style="animation-delay: 1.0s">t</span></span></div>
          `;
        }
      } else {
        msg.textContent = content;
      }

      chatMessages.appendChild(msg);

      // Scroll so the NEW message is at the TOP of the visible area
      if (type === 'bot') {
        msg.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } else {
        // For user messages, scroll to bottom as usual
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Update history
      chatHistory.push({ type, content, doodle });
    }

    function setTyping(visible) {
      typingIndicator.classList.toggle('visible', visible);
      if (visible) {
        avatarLabel.textContent = 'Kurt is thinking...';
      } else {
        avatarLabel.textContent = 'Kurt is listening...';
      }
    }

    function setSpeaking(visible) {
      speakingIndicator.classList.toggle('visible', visible);
      if (visible) {
        avatarLabel.textContent = 'Kurt is speaking...';
      }
    }

    // Create a streaming bot message element that we can append to
    function createStreamingMessage() {
      const welcome = chatMessages.querySelector('.welcome-message');
      if (welcome) welcome.remove();

      const msg = document.createElement('div');
      msg.className = 'message bot streaming';
      const rotation = (Math.random() - 0.5) * 0.8;
      msg.style.transform = `rotate(${rotation}deg)`;

      msg.innerHTML = `
        <div class="text"></div>
        <div class="signature" style="opacity: 0;">— K.V.<span class="bot-suffix"><span class="asterisk">*</span><span class="bot-letter" style="animation-delay: 0.8s">b</span><span class="bot-letter" style="animation-delay: 0.9s">o</span><span class="bot-letter" style="animation-delay: 1.0s">t</span></span></div>
      `;

      chatMessages.appendChild(msg);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      return msg;
    }

    function finalizeStreamingMessage(msgElement, fullText) {
      msgElement.classList.remove('streaming');
      msgElement.querySelector('.signature').style.opacity = '1';
      chatHistory.push({ type: 'bot', content: fullText });
    }

    // Text-to-speech using ElevenLabs
    async function textToSpeech(text) {
      try {
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });

        const data = await response.json();
        if (data.error) {
          console.error('TTS error:', data.error);
          return null;
        }

        return data.audio; // base64 encoded audio
      } catch (err) {
        console.error('TTS fetch error:', err);
        return null;
      }
    }

    // Play audio from base64
    function playAudioBase64(base64Audio) {
      return new Promise((resolve) => {
        const audio = new Audio(`data:audio/mpeg;base64,${base64Audio}`);
        audio.onended = resolve;
        audio.onerror = resolve;
        audio.play().catch(resolve);
      });
    }

    // Process audio queue
    async function processAudioQueue() {
      if (isPlayingAudio || audioQueue.length === 0) return;

      isPlayingAudio = true;
      setSpeaking(true);

      while (audioQueue.length > 0) {
        const audioData = audioQueue.shift();
        if (audioData) {
          await playAudioBase64(audioData);
        }
      }

      isPlayingAudio = false;
      setSpeaking(false);
      avatarLabel.textContent = 'Kurt is listening...';
    }

    function getCurrentContext() {
      // Get the currently highlighted passage
      const highlighted = bookContent.querySelector('.current-passage');
      if (highlighted) {
        return highlighted.textContent;
      }
      // Fallback to first few paragraphs
      const paragraphs = bookContent.querySelectorAll('p');
      let context = '';
      for (let i = 0; i < Math.min(3, paragraphs.length); i++) {
        context += paragraphs[i].textContent + '\n\n';
      }
      return context;
    }

    function renderBookContent(paragraphs) {
      currentParagraphs = paragraphs;

      if (!paragraphs || paragraphs.length === 0) {
        bookContent.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">*</div>
            <div class="empty-state-text">Select a text above to begin reading with Kurt.</div>
          </div>
        `;
        return;
      }

      // Get title from first paragraph if it looks like a title
      let title = '';
      let startIndex = 0;
      if (paragraphs[0].length < 100 && !paragraphs[0].includes('.')) {
        title = paragraphs[0];
        startIndex = 1;
      }

      let html = '';
      if (title) {
        html += `<div class="chapter-title">${title}</div>`;
      }
      html += '<div class="book-text">';

      for (let i = startIndex; i < paragraphs.length; i++) {
        const isCurrentPassage = i === currentPassageIndex + startIndex;
        html += `<p class="${isCurrentPassage ? 'current-passage' : ''}">${paragraphs[i]}</p>`;
      }

      html += '</div>';
      bookContent.innerHTML = html;

      // Add click handlers to paragraphs for manual selection
      const pElements = bookContent.querySelectorAll('p');
      pElements.forEach((p, idx) => {
        p.style.cursor = 'pointer';
        p.addEventListener('click', () => {
          pElements.forEach(el => el.classList.remove('current-passage'));
          p.classList.add('current-passage');
          currentPassageIndex = idx;
        });
      });
    }

    async function loadText(textName) {
      if (!textName) {
        renderBookContent([]);
        return;
      }

      try {
        const response = await fetch(`/api/text/${encodeURIComponent(textName)}`);
        const data = await response.json();

        if (data.error) {
          console.error(data.error);
          return;
        }

        renderBookContent(data.paragraphs);
      } catch (err) {
        console.error('Error loading text:', err);
      }
    }

    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text) return;

      addMessage(text, 'user');
      chatInput.value = '';
      sendBtn.disabled = true;

      // Use streaming for text-voice mode, regular for text mode
      if (currentMode === 'text-voice') {
        await sendMessageStreaming(text);
      } else {
        await sendMessageRegular(text);
      }

      sendBtn.disabled = false;
    }

    // Regular (non-streaming) message send
    async function sendMessageRegular(text) {
      setTyping(true);

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            context: getCurrentContext(),
            history: chatHistory.slice(-12)
          })
        });

        const data = await response.json();
        setTyping(false);

        if (data.doodle) {
          addMessage('', 'bot', data.doodle);
        } else if (data.response) {
          addMessage(data.response, 'bot');
        }
      } catch (err) {
        setTyping(false);
        addMessage('I seem to be having trouble. So it goes.', 'bot');
        console.error('Chat error:', err);
      }
    }

    // Streaming message send with text + voice
    async function sendMessageStreaming(text) {
      setTyping(true);

      // First check for doodle (non-streaming)
      try {
        const checkResponse = await fetch('/api/chat-stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            context: getCurrentContext(),
            history: chatHistory.slice(-12)
          })
        });

        // Check if it's a doodle response (JSON, not SSE)
        const contentType = checkResponse.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          const data = await checkResponse.json();
          setTyping(false);
          if (data.doodle) {
            addMessage('', 'bot', data.doodle);
            return;
          }
        }

        // It's an SSE stream
        setTyping(false);
        const msgElement = createStreamingMessage();
        const textElement = msgElement.querySelector('.text');
        let fullText = '';

        const reader = checkResponse.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));

                if (data.sentence) {
                  // Append sentence to text
                  fullText += (fullText ? ' ' : '') + data.sentence;
                  textElement.innerHTML = fullText;
                  chatMessages.scrollTop = chatMessages.scrollHeight;

                  // Get TTS for this sentence (async, don't await)
                  textToSpeech(data.sentence).then(audio => {
                    if (audio) {
                      audioQueue.push(audio);
                      processAudioQueue();
                    }
                  });
                }

                if (data.done) {
                  finalizeStreamingMessage(msgElement, fullText);
                }

                if (data.error) {
                  console.error('Stream error:', data.error);
                  textElement.innerHTML = 'I seem to be having trouble. So it goes.';
                  finalizeStreamingMessage(msgElement, textElement.innerHTML);
                }
              } catch (e) {
                // Ignore JSON parse errors for incomplete chunks
              }
            }
          }
        }

      } catch (err) {
        setTyping(false);
        addMessage('I seem to be having trouble. So it goes.', 'bot');
        console.error('Streaming error:', err);
      }
    }

    // ========== EVENT LISTENERS ==========

    bookSelect.addEventListener('change', () => {
      loadText(bookSelect.value);
    });

    sendBtn.addEventListener('click', sendMessage);

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // Mode toggle buttons
    modeToggle.addEventListener('click', async (e) => {
      const btn = e.target.closest('.mode-btn');
      if (!btn) return;

      const newMode = btn.dataset.mode;
      if (newMode === currentMode) return;

      // Update button states
      modeToggle.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      currentMode = newMode;

      if (newMode === 'talk') {
        // Switch to Talk mode - show Simli widget, hide idle video
        idleWrapper.classList.add('hidden');
        simliWrapper.classList.add('active');
        avatarLabel.textContent = 'Click Start to talk with Kurt';

        // Initialize Simli widget if not already done
        if (!simliInitialized) {
          await initSimliWidget();
        }

        console.log('Talk mode activated');
      } else {
        // Switch to Text mode - show idle video, hide Simli widget
        simliWrapper.classList.remove('active');
        idleWrapper.classList.remove('hidden');
        avatarLabel.textContent = 'Kurt is listening...';
        console.log('Text mode activated');
      }
    });

    // Initialize Simli widget
    async function initSimliWidget() {
      try {
        avatarLabel.textContent = 'Loading voice mode...';
        simliStartBtn.textContent = 'Loading...';
        simliStartBtn.disabled = true;

        // Get token from backend
        const tokenRes = await fetch('/api/simli-token', { method: 'POST' });
        const tokenData = await tokenRes.json();

        if (tokenData.error) {
          throw new Error(tokenData.error);
        }

        console.log('Got Simli token, creating widget with agentId:', tokenData.agentId);

        // Create the Simli widget element
        // Only token and agentid are required - faceId is configured in the agent on Simli dashboard
        simliWidget = document.createElement('simli-widget');
        simliWidget.setAttribute('token', tokenData.token);
        simliWidget.setAttribute('agentid', tokenData.agentId);
        // Use relative position so it flows in document
        simliWidget.setAttribute('position', 'relative');
        // Replace dotted face with a black placeholder (data URI for 1x1 black pixel)
        // Use asterisk gif as placeholder instead of Simli's green dotted face
        simliWidget.setAttribute('customimage', '/static/vonnegut_asterisk.gif');

        // Add to container
        simliWidgetContainer.appendChild(simliWidget);

        simliInitialized = true;
        avatarLabel.textContent = 'Click Start to talk with Kurt';
        simliStartBtn.textContent = 'Start Conversation';
        simliStartBtn.disabled = false;
        console.log('Simli widget initialized');

        // Setup proxy button click handler
        setupSimliProxyButton();

      } catch (err) {
        console.error('Simli setup error:', err);
        avatarLabel.textContent = 'Voice setup failed. So it goes.';
        simliStartBtn.textContent = 'Failed';
        simliStartBtn.disabled = true;
      }
    }

    // Setup proxy button to click Simli's internal Start button
    function setupSimliProxyButton() {
      simliStartBtn.addEventListener('click', () => {
        console.log('Proxy Start button clicked, searching for Simli internal button...');

        // Try to find and click Simli's internal start button
        // The widget may use shadow DOM or regular DOM
        const findAndClickStart = () => {
          // Try shadow DOM first
          if (simliWidget && simliWidget.shadowRoot) {
            const shadowBtn = simliWidget.shadowRoot.querySelector('button');
            if (shadowBtn) {
              console.log('Found button in shadow DOM:', shadowBtn);
              shadowBtn.click();
              handleSimliStarted();
              return true;
            }
          }

          // Try regular DOM within widget
          if (simliWidget) {
            const regularBtn = simliWidget.querySelector('button');
            if (regularBtn) {
              console.log('Found button in regular DOM:', regularBtn);
              regularBtn.click();
              handleSimliStarted();
              return true;
            }
          }

          // Try finding any clickable element in the container
          const anyButton = simliWidgetContainer.querySelector('button, [role="button"], .start-button, [class*="start"]');
          if (anyButton) {
            console.log('Found alternative button:', anyButton);
            anyButton.click();
            handleSimliStarted();
            return true;
          }

          // If widget has a start method, call it directly
          if (simliWidget && typeof simliWidget.start === 'function') {
            console.log('Calling widget.start() method');
            simliWidget.start();
            handleSimliStarted();
            return true;
          }

          console.log('Could not find Simli start button');
          return false;
        };

        // Try immediately
        if (!findAndClickStart()) {
          // Retry after a short delay in case widget is still loading
          setTimeout(() => {
            if (!findAndClickStart()) {
              avatarLabel.textContent = 'Could not start. Try again.';
            }
          }, 500);
        }
      });
    }

    // Handle successful Simli start
    function handleSimliStarted() {
      simliStartBtn.classList.add('hidden');
      avatarLabel.textContent = 'Connecting to Kurt...';

      // After a delay, update label to indicate ready
      setTimeout(() => {
        avatarLabel.textContent = 'Speak to Kurt...';
      }, 3000);
    }

    // ========== SCROLL TRACKING ==========
    const pageContainer = document.querySelector('.page-container');
    if (pageContainer) {
      pageContainer.addEventListener('scroll', () => {
        // Find which paragraph is most visible
        const paragraphs = bookContent.querySelectorAll('.book-text p');
        const containerRect = pageContainer.getBoundingClientRect();
        const containerCenter = containerRect.top + containerRect.height / 3;

        let closestIdx = 0;
        let closestDist = Infinity;

        paragraphs.forEach((p, idx) => {
          const rect = p.getBoundingClientRect();
          const dist = Math.abs(rect.top - containerCenter);
          if (dist < closestDist) {
            closestDist = dist;
            closestIdx = idx;
          }
        });

        if (closestIdx !== currentPassageIndex) {
          paragraphs.forEach(p => p.classList.remove('current-passage'));
          if (paragraphs[closestIdx]) {
            paragraphs[closestIdx].classList.add('current-passage');
          }
          currentPassageIndex = closestIdx;
        }
      });
    }
  </script>
</body>
</html>
